#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.26
#  in conjunction with Tcl version 8.6
#    Mar 18, 2020 03:51:27 PM CET  platform: Windows NT

import sys
import numpy as np
import time



try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import GUI.MainControl_support as MainControl_support



def set_Tk_var():
    global combobox_x
    combobox_x = tk.StringVar()
    combobox_x.set('fix')
    #combobox_x.trace('w',updateGUI)
    global combobox_y
    combobox_y = tk.StringVar()
    combobox_y.set('fix')
    #combobox_y.trace('w',updateGUI)
    global combobox_z
    combobox_z = tk.StringVar()
    combobox_z.set('fix')
    #combobox_z.trace('w',updateGUI)
    global combobox_th
    combobox_th = tk.StringVar()
    combobox_th.set('map')
    #combobox_th.trace('w',updateGUI)
    global relative_mapping
    relative_mapping = tk.IntVar()
    #relative_mapping.trace('w',updateGUI)
    global start_x
    start_x = tk.StringVar()
    #start_x.trace('w',updateGUI)
    global step_x
    step_x = tk.StringVar()
    #step_x.trace('w',updateGUI)
    global end_x
    end_x = tk.StringVar()
    #end_x.trace('w',updateGUI)
    global N_x
    N_x = tk.StringVar()
    #N_x.trace('w',updateGUIN)
    global start_y
    start_y = tk.StringVar()
    #start_y.trace('w',updateGUI)
    global step_y
    step_y = tk.StringVar()
    #step_y.trace('w',updateGUI)
    global end_y
    end_y = tk.StringVar()
    #end_y.trace('w',updateGUI)
    global N_y
    N_y = tk.StringVar()
    #N_y.trace('w',updateGUIN)
    global N_z
    N_z = tk.StringVar()
    #N_z.trace('w',updateGUIN)
    global end_z
    end_z = tk.StringVar()
    #end_z.trace('w',updateGUI)
    global step_z
    step_z = tk.StringVar()
    #step_z.trace('w',updateGUI)
    global start_z
    start_z = tk.StringVar()
    #start_z.trace('w',updateGUI)
    global start_t
    start_t = tk.StringVar()
    #start_t.trace('w',updateGUI)
    global step_t
    step_t = tk.StringVar()
    #step_t.trace('w',updateGUI)
    global end_t
    end_t = tk.StringVar()
    #end_t.trace('w',updateGUI)
    global N_t
    N_t = tk.StringVar()
    #N_t.trace('w',updateGUIN)
    global Sum
    Sum = tk.StringVar()
    #Sum.trace('w',updateGUI)
    global folderpath
    folderpath = tk.StringVar()
    global main_ax
    main_ax = tk.StringVar()
    main_ax.set('t')

def AbortMap():
    print('Mapping2_support.AbortMap')
    sys.stdout.flush()
    theController.terminatemap()

def CallFolderGrabber():
    print('Mapping2_support.CallFolderGrabber')
    sys.stdout.flush()
    try:
        from tkinter import filedialog
    except:
        import tkFileDialog as filedialog
    file_path = filedialog.askdirectory()
    w.FolderPath.delete(0, tk.END)
    w.FolderPath.insert(0,file_path)

def PauseMap():
    print('Mapping2_support.PauseMap')
    sys.stdout.flush()
    #if theController.mappingstatus == "running":
    theController.pausemap()

def StartMap():
    print('Mapping2_support.StartMap' + theController.mappingstatus)
    sys.stdout.flush()
    if theController.mappingstatus == "not":
        InitializeTheMapping()
    elif theController.mappingstatus == "paused":
        theController.resumemap()
    

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import Mapping2
    Mapping2.vp_start_gui()

def startMainGUI(controlBackend): # main caller
    import Mapping2
    global theController, w ,top_level ,root
    theController= controlBackend #tell everybody about statemashine
    theController.mappingstatus = 'not' #this status is supposed to prevent double-mapping etc. possible values are running, paused, not
    #controller settings to be made:
    top_level,w = Mapping2.create_Toplevel1(theController.root)

    
    #theController.root.mainloop()
def updateGUI(*args):
    valdict,Err = grabAllValues()
    valdict = calcEntries(valdict)
    if Err:
        print("some error in grabAllValues!")
    setAllValues(valdict)
    return True

def updateGUIN(*args):
    print("called")
    valdict,Err = grabAllValues()
    print("grabbed")
    valdict = calcEntries(valdict,Nentered=True)
    print("calculated")
    if Err:
        print("some error in grabAllValues!")
    setAllValues(valdict)
    print("set")
    return True


def changemainax():
    print("not implemented yet - change main axis")


def InitializeTheMapping():
    valdict,err = grabAllValues()
    rel = valdict["relmap"]
    maplist,axorder = calcList(valdict,mainax=valdict["mainax"])
    print("Starting map in mode "+ str(rel))
    print("Mapping positions: " + str(maplist))
    if theController.mappingstatus == 'not':
        theController.runMap(maplist, axorder,relmap=rel,folder=valdict["mapPath"])




def orderMoveVec(vals,names):
    axisassignment = ["x","y","z","t"]
    ovals = ['n','n','n','n']
    for val,name in zip(vals,names):
        try:
            ax = axisassignment.index(name)
            ovals[ax] = val
        except:
            print("err in mapping2, dont know what " + str(name) + " is")
    return ovals

def calcList(valdict,relative=False,mainax='t'):#calculate the list needed to start the map, will consist of the form [[pos1],[pos2],...]
    axis = ["x","y","z","t"]

    arr = []
    arrax = []
    followers = []
    follaxis = []
    secondaries = []
    secondaryaxis=[]

    axisorder=[]

    for ax in axis:
        start = float(valdict[ax+"start"])
        end = float(valdict[ax+"end"])
        num = float(valdict[ax+"N"])
        step = float(valdict[ax+"step"])
        print("vals: " +" "+ str(start) +" "+ str(end) + " "+str(num))
        if not relative:
            thisax = np.linspace(start,end,num,dtype=float)
        else:
            thisax = np.arange(0,num,dtype=float)*step #define only steps 

        print("THISAXIS")
        print(thisax)
        if valdict[ax+"Combo"] == 'map':
            if ax == mainax:
                arr.append(thisax)
                arrax.append(ax) #track names
            else: 
                secondaries.append(thisax)
                secondaryaxis.append(ax)
        elif "follow" in valdict[ax+"Combo"]:
            followers.append([start,end])
            follaxis.append(ax)


    axisorder.append(arrax[0])
    n = len(arr[0])
    for fol,name in zip(followers,follaxis): #first build the main axis with followers
        arr.append(np.linspace(fol[0],fol[1],n))
        axisorder.append(name) #track name for ordering
    arr = np.column_stack(tuple(arr)) #make the matrix out of it
    

    for sec,name in zip(secondaries,secondaryaxis):
        narr = []
        adarr = []
        for entry in sec:
            narr.append(arr)
            adarr.append(entry * np.ones(len(arr)))
        narr = np.concatenate(tuple(narr))
        adarr = np.concatenate(tuple(adarr))
        arr = np.zeros((len(narr),(len(narr[0])+1)))
        arr[:,:len(arr[0])-1]=narr
        arr[:,len(arr[0])-1]=adarr[:]
        axisorder.append(name)

    return arr, axisorder
    

def calcEntries(valdict,relative=False,Nentered=False): #relative would mean calculating 
    axis = ["x","y","z","t"]
    Nsum = 0
    for ax in axis:
        if (not relative) and (not Nentered): #mode for absolute value entering
            start = float(valdict[ax+"start"])
            end = float(valdict[ax+"end"])
            step = float(valdict[ax+"step"])
            try:
                N = float(abs(round((end-start)/step))) +1
            except:
                #print("division error, probably one mapping parameter is zero")
                N=1
            end = start + N*step
            valdict[ax+"start"] = start
            #valdict[ax+"end"] = end
            valdict[ax+"step"] = step
            valdict[ax+"N"] = N
        if (not relative) and Nentered:
            start = float(valdict[ax+"start"])
            end = float(valdict[ax+"end"])
            N = float(abs(valdict[ax+"N"]))
            try:
                step = round(((end-start)/(N-1)),ndigits=5)
            except:
                #print("division error, probably one mapping parameter is zero")
                step = 0
            end = start + N*step
            valdict[ax+"start"] = start
            #valdict[ax+"end"] = end
            valdict[ax+"step"] = step
            valdict[ax+"N"] = N
        # elif relative:#just leave it alone
        if valdict[ax+"Combo"] == "map":
            if Nsum == 0: #first mapped axis
                Nsum = N
            else:
                Nsum = Nsum * N
        elif valdict[ax+"Combo"] == "fix":
            valdict[ax+"N"] = 0

    valdict["sum"] = Nsum
    print(valdict)
    return valdict


def grabAllValues():
    err = False
    valdict = {}
    widgetlist = [w.xCombo,w.startx,w.stepx,w.endx,w.Nx,w.yCombo,w.starty,w.stepy,w.endy,w.Ny,w.zCombo,w.startz,w.stepz,w.endz,w.Nz,w.tCombo,w.startt,w.stept,w.endt,w.Nt,w.Sum,w.mainAx,w.FolderPath]
    namelist = ["xCombo","xstart","xstep","xend","xN","yCombo","ystart","ystep","yend","yN","zCombo","zstart","zstep","zend","zN","tCombo","tstart","tstep","tend","tN","sum","mainax","mapPath"]

    for name, widget in zip(namelist,widgetlist):
        value =  widget.get() #grab text
        try:
            if not ("ombo" in name or "Path" in name or "mainax" in name):
                value = value.replace(",",".")
                value = float(value)
        except:
            value = 0
            err = True
        valdict[name] = value
    
    #read the checkbox(es)
    name = "relmap"
    widget = w.RelMapChk
    state = widget.state()
    if 'alternate' in state or 'selected' in state:
        state = True
    else:
        state = False
    valdict[name] = state

    #print(valdict)
    return valdict,err

def setAllValues(valdict):
    widgetlist = [w.xCombo,w.startx,w.stepx,w.endx,w.Nx,w.yCombo,w.starty,w.stepy,w.endy,w.Ny,w.zCombo,w.startz,w.stepz,w.endz,w.Nz,w.tCombo,w.startt,w.stept,w.endt,w.Nt,w.Sum]
    namelist = ["xCombo","xstart","xstep","xend","xN","yCombo","ystart","ystep","yend","yN","zCombo","zstart","zstep","zend","zN","tCombo","tstart","tstep","tend","tN","sum"]
    #print(valdict)
    for name,widget in zip(namelist,widgetlist):
        if not 'ombo' in name: #exclude, as it should not be changed
            value = valdict[name]
            try:
                value = valdict[name]
            except:
                value = 0
                print("mapping 2 -> error in set all values, "+name+" not in valdict")
            value = "{:.5f}".format(value)
            widget.delete(0,tk.END)
            widget.insert(1,value)

        widget.update_idletasks()

        


def somethinghappened(a,b,c):
    print("some value was changed!!!!!!!")
    print(a)
    print(b)
    print(c)
    print(c.get())



