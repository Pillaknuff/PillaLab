#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 5.4
#  in conjunction with Tcl version 8.6
#    Sep 23, 2020 11:49:45 PM CEST  platform: Windows NT
#    Sep 24, 2020 02:16:09 AM CEST  platform: Windows NT
#    Oct 04, 2020 03:27:00 PM CEST  platform: Windows NT

'''
The XAS Tool is a GUI based Tool to conduct XAS measurements
It is written specifically for beamline P04 at the Petra III storage ring

Data is aquired efficiently by reading and setting Tango buffers for the respective Keithley devices
The Undulator/Monochromator movement will be coordinated in a linear approximation optimized for maximal flux

Author: Philipp Kagerer
Beamline code: Jens Buck
Last change: 04.10.2020

This is the main Code part
XASTool only contains the GUI Definition!
*****
Both can be used to start
*****
Will try to connect to beamline on startup, if this does not work, it will start in a view only mode.
If this connection is not desired, simply set the following Flag to false: 
'''
onlinemode = True
'''
The files are always referenced by name and written into the standard file path
The standard file path is defined by
'''
Filefolder = "C:\\ControlPC\\Monitor Data\\XAS\\XAS_PyTool\\"
Filefolder = "C:\\Users\\Philipp\\Documents\\05_Big_Data\\2020_10_31_Asphere\\"
'''
Simply change it to change the savings directory!, in python paths you should always use a double backslash instead of a single one
The path should end with \\
'''

import sys
import threading
import h5py
import time
import numpy as np
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
try:
    #This would be the proper python 3 solution
    from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
except:
    # working for python 2, looking a bit ancient!
    print("downgrading to python 2 solution and looking vorwurfsvoll!")
    from matplotlib.backends.backend_tkagg import NavigationToolbar2TkAgg as NavigationToolbar2Tk
# Implement the default Matplotlib key bindings.
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
from matplotlib import pyplot as plt
import matplotlib.animation as animation

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

# Predefinitions***************************************************************
GroupMask = "Scan_"
FileOpen = False
ScanRunning = False
running = True
treedict = {}
Stopflag = False
ReadOnly = False

#PyTangoAdresses
adress_Sample = "hasppa3control:10000/asphere/test/keithley6517a"
adress_I0 = "haspp04exp1:10000/p04/keithley6517a/exp1.01"
adress_Undu = "haspp04exp2:10000/p04/plcundulator/1"
adress_Mono = "haspp04exp1:10000/p04/monop04/exp1.01"

# scan and display params
startoffset = -2    # startvalue = startvalue + offset in eV
endoffset =    2    # endvalue = endvalue + offset in eV


def set_Tk_var():                                                           # Necessary in context of GUI crator, sets variables for checkbox
    global normalizeData
    normalizeData = tk.IntVar()

def init(top, gui, *args, **kwargs):                                        # Init called from XAS Tool, sets all necessary variables, creates the window, defines exit behaviour, connects to beamline etc.
    global w, top_level, root, ReadOnly
    w = gui
    top_level = top                                                         # Main GUI Object
    root = top
    top_level.protocol("WM_DELETE_WINDOW", destroy_window)                  # define exit behaviour, see below
    top_level.title("XAS Tool")
    embeddGraphics()                                                        # Embedds the Matplotlib Window and Toolbar into a Frame in the GUI with dummy drawings
    
    if onlinemode:                                                          # Check if connection to beamline is desired
        try:
            IniReadings()                                                   # Initialize all Beamline devices, 2x Keithley, Undulator, Mono by PyTango
            w.Statusbar.configure(text="connected")                         # Display status

        except Exception as e:                                              # Error Handling: Fall back to a offline only file viewer mode
            print("error initalizing beamline devices, starting in read-only mode --> " + str(e))
            w.Statusbar.configure(text="disconnected")
            ReadOnly = True
    else:                                                                   # Desired to start in view only mode anyway
        print("starting in view only mode, change the flag at code top if desired otherwise")
        w.Statusbar.configure(text="disconnected")
        ReadOnly = True
    
    print("Startup finished")

def destroy_window():
    # Function which closes the window and shuts down all processes.
    print("terminating")
    global top_level, fig,subplot,t,canvas,ani, toolbar
    running = False
    if FileOpen:
        h5file.close()
    
    top_level.quit()
    top_level.destroy()
    top_level = None

    
#*********** Data Loading and Display ***************************

def UpdateTreeList():                       # Load updated keylist from HDF5 File, each group is a scan
    if FileOpen:
        GroupTree = h5file.keys()
        print(GroupTree)
        FillInTree(GroupTree)

def FillInTree(Tree):                       # Enter Keys into the Box displaying the datasets available
    global treedict
    treedict = {}
    master = w.Filedisplayer_f
    for widget in master.winfo_children():  #empty first, if already filled
        widget.destroy()

    created = False
    for key in Tree:
        key = str(key)
        print(key)
        treedict[key] = entryLine(master,key)
        treedict[key].Frame1.grid(sticky='w')
        created = True

    if created:                             # GUI updata, resize frame, wait for box to appear/make box appear
        treedict[key].Frame1.wait_visibility()
        bbox = master.bbox()
        w.Filedisplayer.configure(scrollregion=bbox)


def updateList():                           # Button catch
    sys.stdout.flush()
    UpdateTreeList()

def display():                              # Display selected Data, activated on Button click
    subplot.clear()

    normalizeflag = normalizeData.get()
    for key in treedict.keys():             # Iterate all entries
        
        widget = treedict[key]
        if widget.chkboxval.get() == "1":   # If dataset is selected in the scrollbox, see below for the defined checkbox widget
            #print(key)
            group = h5file[key]             # Get Datagroup by Key, Load Data from File

            en = group["E_mono"].value
            entime = group["E_mono_t"].value
            Isample = group["I_sample"].value
            Isampletime = group["I_sample_t"].value
            Imesh = group["I_mesh"].value
            Imeshtime = group["I_mesh_t"].value

                                            # First interpolate the energy-time axis to hardcoded 1000 pts, then interpolate all Datasets onto this axis
            entimeinp = np.linspace(entime.min(),entime.max(),1000)
            eninp = np.interp(entimeinp,entime,en)
            Isampleinp = np.interp(entimeinp,Isampletime,Isample)
            Imeshinp = np.interp(entimeinp,Imeshtime,Imesh)
                                            
            
            if normalizeflag == 1:          
                xas = Isampleinp/Imeshinp
            else:
                xas = Isampleinp

            # *** Display Data***
            subplot.plot(eninp,xas,'.',label=key)
    subplot.legend(loc=0, frameon=False)
    canvas.draw()

def openFile():                             # open HDF5 file
    global FileOpen, h5file
    if FileOpen:                            # close previous file, if still open
        try:
            h5file.close()
        except Exception as e:
            print("error closing: " + str(e))

    filename = w.Filename.get()             # pull designated filename from GUI
    if filename == "":                      # fallback to  standard
        filename = "ScanFile"

    fullpath = Filefolder + filename + ".h5"

    
    try:
        h5file = h5py.File(fullpath, 'a')   # open to write
        FileOpen = True
    except Exception as e:
        FileOpen = False
        print("error while opening hdf5: " + str(e))
    
    return FileOpen                         # success flag


#****************** other Controls without functions yet ***************************
def changeToCM():
    print('not Implemented yet!')
    sys.stdout.flush()

def changeToCP():
    print('not Implemented yet!')
    sys.stdout.flush()

def runpmmpScan():
    print('not implemented')
    sys.stdout.flush()

# *****************************Active scanning functions*****************************************


def runScan():
    print('Starting data aquisition, press stop, when scan is finished')
    sys.stdout.flush()
    start,end,speed,valid = getScanParams()

    if not FileOpen:
        openFile()

    if (valid and FileOpen) and not ScanRunning:
        mythread = threading.Thread(target=XASScan, args = (start,end,speed))
        mythread.start()



def stopScan():
    '''
    At the moment used to stop data aquisition by setting the stop-flag
    In later cases should be used to also stop movement of Mono and Undu
    '''
    print('Data Aquisition terminated!')
    sys.stdout.flush()
    global Stopflag
    Stopflag = True

def getScanParams():
    '''
    Read scan parameters from GUI
    If converstion to float fails data is flagged as invalid and no scan will be started
    '''
    start = w.Estart.get()
    end = w.Eend.get()
    speed = w.Speed.get()
    try:
        start = float(start)
        end = float(end)
        speed = float(speed)
        valid = True
    except:
        start = 0
        end = 0
        speed = 0
        valid = False
    return start,end,speed,valid





#*****************Scanning routines********************************

def IniReadings(buf_max=10000):

    '''
    Called at startup to Initialize connection with the Keithleys,
    Mono and Undulator.
    Resets all devices to change buffer size and reading speed
    Will cause COM server to crash.
    If possible this tool should thus stay open as long as in use
    '''

    import TangoMonitor2 as tm
    

    global SampleReader, I0Reader, MonoReader, UnduReader

    # avalilable adresses
    # adress_Sample = "haspa3control:10000/asphere/test/keithley6517a"
    # adress_I0 = "haspp04exp1:10000/p04/keithley6517a/exp1.01"
    # adress_Undu = "haspp04exp2:10000/p04/pkundulator"
    # adress_Mono = "haspp04exp1:10000/p04/monop04"

    print("Ini Sample Keithley")
    SampleReader = tm.TangoMonitor(adress_Sample,'Current',PollingPeriod=100,buf_max=buf_max)
    print("Ini I0 Keithley")
    I0Reader = tm.TangoMonitor(adress_I0,'Current',PollingPeriod=100,buf_max=buf_max)
    print("Ini Undulator")
    UnduReader = tm.TangoMonitor(adress_Undu,'CurrentGap',PollingPeriod=500,buf_max=buf_max)
    print("Ini Mono")
    MonoReader = tm.TangoMonitor(adress_Mono,'Position',PollingPeriod=500,buf_max=buf_max)

    #@Jens: Initialize control over Undulator Motor, Monochromator position, scan info and reading of Undulator phase here
    # if automatic Helicity switch is desired also set a method to call the Helicity switch skript here

    print(SampleReader.FetchData(clear_buffer=True)) # read to clear buffer
    print(I0Reader.FetchData(clear_buffer=True)) # read to clear buffer
    print(UnduReader.FetchData(clear_buffer=True)) # read to clear buffer
    print(MonoReader.FetchData(clear_buffer=True)) # read to clear buffer

def XASScan(start,end,speed):
    import ApproxGapTable as agt                            # approximator for scan speed, gap values and similar

    global ScanRunning
    global SampleReader, I0Reader, MonoReader

    ScanRunning = True
    w.Statusbar.configure(text="aquiring Data")

    ## *** uncomment, if you want to use a dummy mode ***
    # energy = np.linspace(start,end,1000)
    # energytime = np.linspace(1,5,1000)
    # Isample = np.random.rand(1010)
    # Isampletime = np.linspace(1,5,1010)
    # Imesh = np.random.rand(900)
    # Imeshtime = np.linspace(1,5,900)
    ## *** stop uncomment ***


    # ****** compute speed, start, end etc. ********************************************************************************************************
    actstart = start + startoffset                          # start and endvalues modulo offset to stabilize driving undulator
    actend = end + endoffset
    par = agt.MakeScanParams(actstart,actend,speed)         # call to linear approximation Tool to estimat optimal driving params

    # *** Definitions of par, only for documentation ***
    # return {'mono_start':hv_start,
    #     'mono_end':hv_end,
    #     'mono_speed':hv_speed,
    #     'scan_time':scan_time,
    #     'undu_start':gap_start,
    #     'undu_speed_um':gap_v,
    #     'undu_speed':gap_v_undu,
    #     'hv_axis':hv_theo,
    #     'hv_diff':hv_scan-hv_theo,
    #     'flux_diff': RelFlux(hv_theo, hv_scan),
    #     'flux_worst':-p_lin['fun']
    #     }
    # *** end Definition


    # ****** set undulator and mono to startvalues*********************************************************************************************
    # @Jens, to be defined, variables are written into par
    from PyTango import DeviceProxy as DP
    from epics import PV



    # *** Aquire base data to get timestamps for the cutoff ***
    SampleReader.FetchData(clear_buffer=False)                      # pull data into buffer of TangoMonitor Library
    MonoReader.FetchData(clear_buffer=False)
    I0Reader.FetchData(clear_buffer=False)
    UnduReader.FetchData(clear_buffer=False)

    Isampletime_start = SampleReader.buf_timestamp.copy()           # Copy Buffer of data as "time-baseline", copy is important to avoid overwrite with next pull!
    energytime_start = MonoReader.buf_timestamp.copy()
    Imeshtime_start = I0Reader.buf_timestamp.copy()
    eUndulatortime_start = UnduReader.buf_timestamp.copy()
    # -> All the data between here!!!!!######

    #************ Start Scan with Undulator and Mono *****************************
    # @Jens, to be defined, variables are start, end, speed, parameter set is found in par

    #************ Start waiting loop until stop button is pressed*****************
    # This should be replaced with the respective "waiting for the scan to finish" method, which will also terminate the scan if stop is pushed!

    global Stopflag                                                 # global flag, which can be triggered by pushing the stop button
    Stopflag = False                                                # initialize as false, will be overwritten on button push
    while not Stopflag:                                             # wait until pushed
        time.sleep(1)

    # -> And here!!!! Will be recorded.######
    SampleReader.FetchData(clear_buffer=False)                      # Fetch Data from Device to Buffer
    MonoReader.FetchData(clear_buffer=False)
    I0Reader.FetchData(clear_buffer=False)
    UnduReader.FetchData(clear_buffer=False)

    Isample = SampleReader.buffer.copy()                            # Read Data from Buffer, duplicate to avoid object overwriting issues
    Isampletime = SampleReader.buf_timestamp.copy()

    energy = MonoReader.buffer.copy()
    energytime = MonoReader.buf_timestamp.copy()

    Imesh = I0Reader.buffer.copy()
    Imeshtime = I0Reader.buf_timestamp.copy()

    eUndulator = UnduReader.buffer.copy()
    eUndulatortime = UnduReader.buf_timestamp.copy()

    # @Jens: pull data for polarisation and insert if desired!
    scan_Info = ["polarisation = no idea",]                         # info string for setting additional information without timestamp as single point dataset, can be used for things like polarisation and similar
    print("Scan finished, saving data")
    
    # print(energy)
    # print(energytime)
    # print(Imesh)
    # print(Isample)

    # *** Save Data into HDF5 file
    SaveData(energy,energytime,Isample,Isampletime,Imesh,Imeshtime,eUndulator,eUndulatortime, Isampletime_start, energytime_start, Imeshtime_start, eUndulatortime_start,scan_Info)
    w.Statusbar.configure(text="ready")
    print("saved")
    ScanRunning = False                                             # Set Flag to enable controls for next scan!

def SaveData(energy,energytime,Isample,Isampletime,Imesh,Imeshtime,eUndulator,eUndulatortime,Isampletime_start, energytime_start, Imeshtime_start, eUndulatortime_start,scan_Info="no furter info in here"):

    '''
    Find index in Dataset, where the scan started
    The Buffer always reads until overflowing (ring-buffer)
    Buffer size should always be way bigger, than the estimated scan size
    The last entry of the "befor data" is used to select the starting point for each scan
    '''
    # Starting indizes for actual data
    Isampleindex = np.where(Isampletime==Isampletime_start[len(Isampletime_start)-1])[0][0]
    energyindex = np.where(energytime == energytime_start[len(energytime_start)-1])[0][0]
    Imeshindex = np.where(Imeshtime == Imeshtime_start[len(Imeshtime_start)-1])[0][0]
    eUnduIndex = np.where(eUndulatortime == eUndulatortime_start[len(eUndulatortime_start)-1])[0][0]

    # Unique Group-name creation, uses mask + running integer
    i=0
    while True:                                     # create group in loop
        groupname = GroupMask + str(i) 
        try:                                        # if group already existing, this is not possible
            g1 = h5file.create_group(groupname)
            break
        except:
            i+=1


    ''' 
    Save Data into hdf5 file
    Structure as follows
    
    hdf5 file
    -> Data group (=single scan)
        -> value entry (measured data for each channel)
        -> +"_t" = timestamp for the respective entry
    at the moment: E_mono, I_sample, I_mesh, Gap_Undu

    for optional "one-point" info use Scan Info as string list
    '''
    
    energyset = g1.create_dataset("E_mono", data=energy[energyindex:])                  # Creating dataset with data equals saving the data 
    energytimeset = g1.create_dataset("E_mono_t", data=energytime[energyindex:])
    Isampleset = g1.create_dataset("I_sample", data=Isample[Isampleindex:],)
    Isampletimeset = g1.create_dataset("I_sample_t", data=Isampletime[Isampleindex:],)
    Imeshset = g1.create_dataset("I_mesh", data=Imesh[Imeshindex:],)
    Imeshtimeset = g1.create_dataset("I_mesh_t", data=Imeshtime[Imeshindex:],)
    Imeshset = g1.create_dataset("Gap_Undu", data=eUndulator[eUnduIndex:],)
    Imeshtimeset = g1.create_dataset("Gap_Undu_t", data=eUndulatortime[eUnduIndex:],)

    ScanInfoset = g1.create_dataset("Scan Info", data=scan_Info)

    h5file.flush()                                                                      # write buffer to file, to avoid crash with file still empty

#*** Code used to setup the initial window and graphics content
#*****************graphic windows************************

def embeddGraphics():                                   # function creating the graphics window and displaying a dummy function
    global fig,subplot,t,canvas,ani, toolbar


    fig = plt.figure(num=1,figsize=(5, 4), dpi=100)     # create figure, create dummy dataset and plot it in subplot
    t = np.arange(0, 3, .01)
    subplot = fig.add_subplot(111)
    subplot.plot(t, 2 * np.sin(2 * np.pi * t),".")

    

    canvas = FigureCanvasTkAgg(fig, master=w.Displayframe)  # A tkinter drawingArea carrying the plot 
    
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)    # place widget in window
    toolbar = NavigationToolbar2Tk(canvas, w.Toolframe)                 # create toolbar, type of toolbar depends on the imports above, falls back to oder variant if python 2 is used
    toolbar.update()
    canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)    
    canvas.draw()                                                       # display graphics


#****************entry class*********************************
class entryLine:                                                            # Class for entry widget displaying the checkbox for each dataset, will be placed multiple times in the scrolled entry widget
    def __init__(self,master,name):
        self.chkboxval = tk.StringVar()                                     # Variable declaration for the checkbox implemented as a class variable, call this with object.chkboxval.get()

        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'                         # Style configurations from here on
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        self.style = ttk.Style()

        self.Frame1 = tk.Frame(master,height=30,width=360)
        #self.Frame1.place(relx=0.2, rely=0.178, relheight=0.078, relwidth=0.375)
        self.Frame1.configure(relief='groove')
        self.Frame1.configure(borderwidth="2")
        self.Frame1.configure(relief="groove")
        self.Frame1.configure(background="#d9d9d9")

        self.Label = tk.Label(self.Frame1)
        self.Label.place(relx=0.044, rely=0.286, height=19, width=184)
        self.Label.configure(background="#d9d9d9")
        self.Label.configure(disabledforeground="#a3a3a3")
        self.Label.configure(foreground="#000000")
        self.Label.configure(text=name)

        self.style.map('TCheckbutton',background=[('selected', _bgcolor), ('active', _ana2color)])
        self.Checked = ttk.Checkbutton(self.Frame1)
        self.Checked.place(relx=0.889, rely=0.286, relwidth=0.093, relheight=0.0, height=21)
        self.Checked.configure(variable=self.chkboxval)
        self.Checked.configure(takefocus="")
        self.Checked.configure(cursor="fleur")





if __name__ == '__main__':
    import XASTool
    XASTool.vp_start_gui()